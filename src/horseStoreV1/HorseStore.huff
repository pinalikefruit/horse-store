// 1. Where did this data come from? How did Remix know to send this data?
//    1. 0xe026c0170000000000000000000000000000000000000000000000000000000000000001
//    2. How does the EVM know how to interpret/interact with data?
// 2. How does Remix know to update the number of horses with this data?


// The skeleton of our `MAIN` macro is outlined with the `takes` and `returns` syntax specifying the stack operations it will perform

// 60008060093d393df3 - Contract creation bytecode
// 60018060093d393df35f - add 5F push 0 onto the stack
// 60028060093d393df3 5f 35
#define macro MAIN() = takes(0) returns(0) {
    0x00               // [0]
    // 0x02           TOP [2,0] BOTTOM
    calldataload       // [calldata] take the 0 in the stack as a input offset for take the 32 bytes
    // 0xe026c0170000000000000000000000000000000000000000000000000000000000000001
    // first 32 bytes 0xe026c01700000000000000000000000000000000000000000000000000000000-00000001
    // shf 56/2(hex) * 8 (bits) = 224 
    // convert 225 dec to hex -> cast --to-base 224 hex 0xe0
    0xE0
    shr

    // If f_select = 0xcdfead2e = updateHorseNumber -> jump to that data in the contract
    // If f_select = 0xe026c017 = readNumberOfHorses -> jump to that data in the contract 

    // updateHorseNumber selector 
    0xcdfead2e
    eq // [true_if_func_selector_matches]
    updateJump               // [updateHorseNumberProgramCounter, true/false]
    jumpi                    // []

    updateJump:
        SET_NUMBER_OF_HORSES()
}

#define macro SET_NUMBER_OF_HORSES() = takes(0) returns(0){}

/// cast --to-base 0x0102 bin
/// 0b 10000 0000010

// For take the function selector:
// PUSH0
// calldataload
// PUSH1 0xE0
// SHR
